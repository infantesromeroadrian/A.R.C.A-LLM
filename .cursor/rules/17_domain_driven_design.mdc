---
description: Domain-Driven Design (DDD) tactical patterns - Enforce rich domain models, prevent anemic models, and maintain proper layered architecture
globs: 
alwaysApply: true
---

# Domain-Driven Design (DDD) Tactical Patterns

## ðŸŽ¯ Purpose

Enforce Domain-Driven Design principles to create maintainable, business-focused software:
- Prevent **Anemic Domain Models** (anti-pattern)
- Enforce **Rich Domain Models** with encapsulated business logic
- Apply **Ubiquitous Language** consistently
- Implement proper **Tactical Building Blocks**
- Maintain clean **Layered Architecture**

---

## ðŸš¨ CRITICAL: Detect and Prevent Anemic Models

### âŒ Anemic Model (Anti-Pattern) - NEVER DO THIS

**Signs of Anemic Model:**
- Classes with only getters/setters
- Business logic in separate "Service" classes
- No behavior in domain objects
- Easy to violate business rules

```python
# âŒ BAD - Anemic Model
class BankAccount:
    def __init__(self, account_number: str, balance: float):
        self.account_number = account_number
        self.balance = balance  # Public, no protection
    
    def get_balance(self) -> float:
        return self.balance
    
    def set_balance(self, new_balance: float) -> None:
        self.balance = new_balance  # No validation!

# âŒ Logic outside the model
class BankAccountService:
    def withdraw(self, account: BankAccount, amount: float) -> None:
        if amount > account.get_balance():
            raise ValueError("Insufficient funds")
        account.set_balance(account.get_balance() - amount)
```

**Problems:**
- Anyone can set balance directly
- Business rules can be bypassed
- Logic scattered across services
- Hard to maintain invariants

### âœ… Rich Domain Model - ALWAYS DO THIS

**Characteristics:**
- Encapsulated data (private attributes)
- Business logic inside the model
- Enforced invariants
- Clear domain operations

```python
# âœ… GOOD - Rich Domain Model
from decimal import Decimal
from dataclasses import dataclass
from datetime import datetime

class BankAccount:
    """Rich Domain Model with encapsulated logic."""
    
    DAILY_WITHDRAWAL_LIMIT = Decimal("5000.00")
    
    def __init__(self, account_number: str, holder_name: str, initial_balance: Decimal = Decimal("0.00")):
        # Validation in constructor
        if initial_balance < 0:
            raise ValueError("Initial balance cannot be negative")
        
        self._account_number = account_number  # Private
        self._holder_name = holder_name
        self._balance = initial_balance
        self._is_active = True
        self._transactions: list = []
    
    @property
    def balance(self) -> Decimal:
        """Read-only balance access."""
        return self._balance
    
    def deposit(self, amount: Decimal, description: str = "") -> None:
        """
        Deposit money - business logic encapsulated.
        Enforces business rules automatically.
        """
        # Business rule: Amount must be positive
        if amount <= 0:
            raise ValueError("Deposit amount must be positive")
        
        # Business rule: Account must be active
        if not self._is_active:
            raise ValueError("Cannot deposit to inactive account")
        
        # Apply change
        self._balance += amount
        
        # Record transaction
        self._transactions.append({
            'type': 'DEPOSIT',
            'amount': amount,
            'date': datetime.now(),
            'description': description
        })
    
    def withdraw(self, amount: Decimal, description: str = "") -> None:
        """
        Withdraw money - business logic encapsulated.
        Multiple business rules enforced.
        """
        # Business rules validation
        if amount <= 0:
            raise ValueError("Withdrawal amount must be positive")
        
        if not self._is_active:
            raise ValueError("Cannot withdraw from inactive account")
        
        if self._balance < amount:
            raise ValueError(f"Insufficient funds. Available: {self._balance}")
        
        if amount > self.DAILY_WITHDRAWAL_LIMIT:
            raise ValueError(f"Exceeds daily limit of {self.DAILY_WITHDRAWAL_LIMIT}")
        
        # Apply change
        self._balance -= amount
        
        # Record transaction
        self._transactions.append({
            'type': 'WITHDRAWAL',
            'amount': amount,
            'date': datetime.now(),
            'description': description
        })
    
    def transfer_to(self, destination_account: 'BankAccount', amount: Decimal) -> None:
        """Domain operation composing other operations."""
        self.withdraw(amount, f"Transfer to {destination_account._account_number}")
        destination_account.deposit(amount, f"Transfer from {self._account_number}")
```

**Benefits:**
- âœ… Impossible to violate business rules
- âœ… Logic is where it belongs
- âœ… Easy to test
- âœ… Self-documenting

---

## ðŸ—£ï¸ Ubiquitous Language

**Rule:** Use domain terms consistently in code, documentation, and conversations.

### âŒ BAD - Technical Terms Not From Domain

```python
class UserRecord:  # âŒ "UserRecord" - technical term
    def update_bal(self, amt: float) -> None:  # âŒ Abbreviations
        self.bal += amt

class TransactionProcessor:  # âŒ Generic name
    def process(self, data: dict) -> None:  # âŒ What does "process" mean?
        pass
```

### âœ… GOOD - Ubiquitous Language From Domain

```python
class Cliente:  # âœ… Exact term used by business
    def cambiar_direccion_facturacion(self, nueva_direccion: 'Direccion') -> None:
        """âœ… Method name from domain vocabulary."""
        self._direccion_facturacion = nueva_direccion

class ProcesadorPagos:  # âœ… Business term
    def procesar_pago_con_tarjeta(self, tarjeta: 'TarjetaCredito', monto: 'Dinero') -> 'ResultadoPago':
        """âœ… Operation name matches business process."""
        pass
```

**Enforcement Rules:**
1. Class names = Domain concepts (nouns from business)
2. Method names = Domain operations (verbs from business)
3. Avoid abbreviations (unless domain uses them)
4. No generic names like "Manager", "Handler", "Processor" unless domain uses them

---

## ðŸ—ï¸ Tactical Building Blocks

### 1. Entities

**Definition:** Objects with unique identity that persists over time.

**Rules:**
- âœ… MUST have unique ID
- âœ… ID must be immutable
- âœ… Equality based on ID, not attributes
- âœ… Can be mutable

```python
from uuid import uuid4, UUID

class Order:  # âœ… Entity
    """Entity - Identity matters."""
    
    def __init__(self, customer_id: UUID, order_id: UUID = None):
        self._order_id = order_id or uuid4()  # Immutable ID
        self._customer_id = customer_id
        self._items: list = []
        self._status = "DRAFT"
    
    @property
    def order_id(self) -> UUID:
        """Immutable ID accessor."""
        return self._order_id
    
    def __eq__(self, other) -> bool:
        """Equality based on ID."""
        if not isinstance(other, Order):
            return False
        return self._order_id == other._order_id
    
    def __hash__(self) -> int:
        """Hash based on ID."""
        return hash(self._order_id)
```

---

### 2. Value Objects

**Definition:** Objects without conceptual identity. Defined only by attributes. Immutable.

**Rules:**
- âœ… MUST be immutable (frozen=True)
- âœ… Equality based on ALL attributes
- âœ… Can be replaced, not modified
- âœ… No ID needed

```python
from dataclasses import dataclass
from decimal import Decimal

@dataclass(frozen=True)  # âœ… Immutable
class Money:  # âœ… Value Object
    """Value Object - No identity, immutable."""
    amount: Decimal
    currency: str = "USD"
    
    def add(self, other: 'Money') -> 'Money':
        """Operations return NEW value objects."""
        if self.currency != other.currency:
            raise ValueError("Cannot add different currencies")
        return Money(self.amount + other.amount, self.currency)
    
    def multiply(self, factor: int) -> 'Money':
        """New value object created."""
        return Money(self.amount * factor, self.currency)

@dataclass(frozen=True)
class Address:  # âœ… Value Object
    """Value Object - Immutable address."""
    street: str
    city: str
    zip_code: str
    country: str
    
    def with_new_zip_code(self, new_zip: str) -> 'Address':
        """'Changing' means creating new instance."""
        return Address(self.street, self.city, new_zip, self.country)
```

**When to Use:**
- âœ… Identity doesn't matter (two addresses with same data are same)
- âœ… Represents a measurement, quantity, or descriptor
- âœ… Examples: Money, DateRange, Address, Email, PhoneNumber

---

### 3. Aggregates

**Definition:** Cluster of related objects treated as a unit. Has an Aggregate Root.

**Rules:**
- âœ… Has one Aggregate Root (an Entity)
- âœ… Root is the ONLY entry point
- âœ… External references only to root
- âœ… Root enforces ALL invariants
- âœ… Saved/loaded as a unit

```python
from typing import List
from dataclasses import dataclass

@dataclass(frozen=True)
class OrderLine:  # âœ… Part of aggregate
    """Value Object - Internal to Order aggregate."""
    product_id: str
    product_name: str
    unit_price: Decimal
    quantity: int
    
    def subtotal(self) -> Decimal:
        return self.unit_price * self.quantity

class Order:  # âœ… Aggregate Root
    """
    Aggregate Root - Controls all access to OrderLines.
    Enforces invariants across the entire aggregate.
    """
    
    MAX_ITEMS = 50  # Aggregate invariant
    
    def __init__(self, customer_id: UUID, order_id: UUID = None):
        self._order_id = order_id or uuid4()
        self._customer_id = customer_id
        self._lines: List[OrderLine] = []  # Internal, not exposed
        self._status = "DRAFT"
    
    @property
    def total(self) -> Decimal:
        """Calculated from internal state."""
        return sum(line.subtotal() for line in self._lines)
    
    def add_product(self, product_id: str, name: str, price: Decimal, quantity: int) -> None:
        """
        ONLY way to add products - through Aggregate Root.
        Root enforces invariants.
        """
        # Invariant: Can only modify draft orders
        if self._status != "DRAFT":
            raise ValueError("Cannot modify confirmed order")
        
        # Invariant: Max items limit
        total_items = sum(line.quantity for line in self._lines)
        if total_items + quantity > self.MAX_ITEMS:
            raise ValueError(f"Cannot exceed {self.MAX_ITEMS} items")
        
        # Add line
        new_line = OrderLine(product_id, name, price, quantity)
        self._lines.append(new_line)
    
    def confirm(self) -> None:
        """State transition - validates invariants."""
        if not self._lines:
            raise ValueError("Cannot confirm empty order")
        
        self._status = "CONFIRMED"
    
    def get_lines(self) -> List[OrderLine]:
        """Return COPY, not internal list."""
        return self._lines.copy()
```

**Aggregate Design Rules:**
1. âœ… Keep aggregates small
2. âœ… One aggregate per transaction
3. âœ… Reference other aggregates by ID only
4. âœ… Use domain events for cross-aggregate consistency

---

### 4. Repositories

**Definition:** Abstraction for retrieving and persisting Aggregates.

**Rules:**
- âœ… One repository per Aggregate Root
- âœ… Interface defined in Domain Layer
- âœ… Implementation in Infrastructure Layer
- âœ… Collection-like interface
- âœ… Hide persistence details

```python
from abc import ABC, abstractmethod
from typing import Optional, List

# âœ… Interface in DOMAIN layer
class OrderRepository(ABC):
    """
    Repository interface - Domain defines what it needs.
    Infrastructure provides implementation.
    """
    
    @abstractmethod
    def save(self, order: Order) -> None:
        """Save or update order."""
        pass
    
    @abstractmethod
    def get_by_id(self, order_id: UUID) -> Optional[Order]:
        """Retrieve order by ID."""
        pass
    
    @abstractmethod
    def get_by_customer(self, customer_id: UUID) -> List[Order]:
        """Get all orders for customer."""
        pass
    
    @abstractmethod
    def delete(self, order_id: UUID) -> None:
        """Delete order."""
        pass

# âœ… Implementation in INFRASTRUCTURE layer
class OrderRepositorySQL(OrderRepository):
    """Concrete implementation - knows about SQL."""
    
    def __init__(self, db_connection):
        self._db = db_connection
    
    def save(self, order: Order) -> None:
        """Save to SQL database."""
        # SQL implementation here
        pass
    
    def get_by_id(self, order_id: UUID) -> Optional[Order]:
        """Load from SQL database."""
        # SQL implementation here
        pass
```

---

### 5. Domain Services

**Definition:** Operations that don't belong to a single Entity or Value Object.

**When to Use:**
- Operation involves multiple aggregates
- Stateless operation
- Pure domain logic that doesn't fit in entities

```python
class TransferService:
    """
    Domain Service - Coordinates two BankAccount aggregates.
    Doesn't belong to one account.
    """
    
    def __init__(self, account_repo: 'AccountRepository'):
        self._account_repo = account_repo
    
    def transfer_between_accounts(
        self,
        source_account_id: UUID,
        destination_account_id: UUID,
        amount: Decimal
    ) -> None:
        """
        Domain Service - coordinates multiple aggregates.
        Pure domain logic.
        """
        # Load both accounts
        source = self._account_repo.get_by_id(source_account_id)
        destination = self._account_repo.get_by_id(destination_account_id)
        
        if not source or not destination:
            raise ValueError("Account not found")
        
        # Use domain operations from each aggregate
        source.withdraw(amount, f"Transfer to {destination_account_id}")
        destination.deposit(amount, f"Transfer from {source_account_id}")
        
        # Save both
        self._account_repo.save(source)
        self._account_repo.save(destination)
```

**Domain Service vs Application Service:**
- **Domain Service:** Pure business logic, no orchestration
- **Application Service:** Orchestrates use cases, coordinates domain objects

---

## ðŸ›ï¸ Layered Architecture

**CRITICAL:** Maintain strict layer separation.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  PRESENTATION LAYER (UI)            â”‚  â† Controllers, DTOs, Views
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  APPLICATION LAYER                  â”‚  â† Use Cases, Orchestration
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  DOMAIN LAYER (Core Business Logic) â”‚  â† Entities, VOs, Aggregates
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  INFRASTRUCTURE LAYER               â”‚  â† Database, External APIs
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Dependency Rules (CRITICAL)

```
âœ… ALLOWED:
Presentation â†’ Application â†’ Domain â† Infrastructure
                                 â†‘
                                 â””â”€â”€ Only through interfaces

âŒ FORBIDDEN:
Domain â†’ Infrastructure  (NEVER!)
Domain â†’ Application     (NEVER!)
Domain â†’ Presentation    (NEVER!)
```

### Layer Responsibilities

#### Domain Layer
```python
# âœ… Domain Layer - Pure business logic, no dependencies

class Order:  # Entity
    def confirm(self) -> None:
        """Pure business logic."""
        if not self._lines:
            raise ValueError("Cannot confirm empty order")
        self._status = "CONFIRMED"

class OrderRepository(ABC):  # Interface
    """Domain defines WHAT it needs."""
    @abstractmethod
    def save(self, order: Order) -> None:
        pass
```

#### Application Layer
```python
# âœ… Application Layer - Orchestration, no business logic

class OrderApplicationService:
    """Use case orchestration."""
    
    def __init__(
        self,
        order_repo: OrderRepository,
        customer_repo: CustomerRepository
    ):
        self._order_repo = order_repo
        self._customer_repo = customer_repo
    
    def create_order(self, customer_id: UUID, items: List[dict]) -> UUID:
        """
        Use case: Create order.
        Orchestrates domain operations.
        """
        # 1. Validate customer exists
        customer = self._customer_repo.get_by_id(customer_id)
        if not customer:
            raise ValueError("Customer not found")
        
        # 2. Create order (domain operation)
        order = Order(customer_id)
        
        # 3. Add items (domain operations)
        for item in items:
            order.add_product(
                item['product_id'],
                item['name'],
                Decimal(item['price']),
                item['quantity']
            )
        
        # 4. Confirm order (domain operation)
        order.confirm()
        
        # 5. Save (infrastructure)
        self._order_repo.save(order)
        
        return order.order_id
```

#### Infrastructure Layer
```python
# âœ… Infrastructure Layer - Implementation details

class OrderRepositorySQL(OrderRepository):
    """Implements domain interface."""
    
    def save(self, order: Order) -> None:
        """SQL implementation."""
        # Database access here
        pass
```

#### Presentation Layer
```python
# âœ… Presentation Layer - API endpoints

from flask import Flask, request, jsonify

class OrderController:
    """REST API controller."""
    
    def __init__(self, service: OrderApplicationService):
        self._service = service
    
    def create_order_endpoint(self, request_data: dict) -> tuple:
        """HTTP endpoint."""
        try:
            order_id = self._service.create_order(
                UUID(request_data['customer_id']),
                request_data['items']
            )
            return {'order_id': str(order_id)}, 201
        except ValueError as e:
            return {'error': str(e)}, 400
```

---

## âœ… DDD Validation Checklist

### Before Committing Code:

**Domain Layer:**
- [ ] No dependencies on other layers
- [ ] Business logic is in domain objects, not services
- [ ] Entities have identity and behavior
- [ ] Value Objects are immutable
- [ ] Aggregates enforce invariants
- [ ] Ubiquitous Language used consistently

**Anemic Model Check:**
- [ ] Domain classes have behavior, not just getters/setters
- [ ] Business rules enforced by domain objects themselves
- [ ] Cannot violate invariants from outside

**Aggregate Design:**
- [ ] Clear Aggregate Root
- [ ] Aggregate is small enough (not too many entities)
- [ ] Invariants are maintained within aggregate boundary
- [ ] External references are by ID only

**Repository:**
- [ ] One repository per Aggregate Root
- [ ] Interface in domain, implementation in infrastructure
- [ ] Collection-like interface (save, get, delete)

**Layered Architecture:**
- [ ] Domain has zero dependencies
- [ ] Infrastructure implements domain interfaces
- [ ] Application orchestrates, doesn't contain business logic
- [ ] Presentation only maps to/from DTOs

---

## ðŸš¨ Common DDD Violations to Detect

### 1. Anemic Domain Model
```python
# âŒ VIOLATION - Detect and reject
class Product:
    def __init__(self):
        self.price = 0  # Public, no protection
        self.name = ""
    
    def get_price(self): return self.price
    def set_price(self, p): self.price = p  # No validation!

# Logic in service instead of domain
class ProductService:
    def change_price(self, product, new_price):
        product.set_price(new_price)  # âŒ Logic outside domain
```

### 2. Domain Depending on Infrastructure
```python
# âŒ VIOLATION - Detect and reject
class Order:  # Domain Entity
    def save_to_database(self):  # âŒ Domain knowing about database!
        connection = psycopg2.connect(...)  # âŒ Infrastructure in domain
        cursor.execute("INSERT INTO orders...")
```

### 3. Breaking Aggregate Boundaries
```python
# âŒ VIOLATION - Detect and reject
order = order_repo.get_by_id(order_id)
line = order.get_lines()[0]  # Getting internal object
line.quantity = 999  # âŒ Modifying internal state directly!
```

### 4. Missing Ubiquitous Language
```python
# âŒ VIOLATION - Detect and reject
class DataManager:  # âŒ Generic name
    def process(self, data):  # âŒ What does "process" mean?
        pass
```

---

## ðŸ“š Quick Reference

**Rich Domain Model Pattern:**
```python
class DomainEntity:
    def __init__(self, ...):
        self._private_state = ...  # Encapsulated
    
    @property
    def public_readonly(self):  # Read-only access
        return self._private_state
    
    def domain_operation(self, ...):  # Business logic here
        # Validate business rules
        # Apply changes
        # Maintain invariants
        pass
```

**Value Object Pattern:**
```python
@dataclass(frozen=True)  # Always immutable
class ValueObject:
    attribute1: type
    attribute2: type
    
    def operation(self) -> 'ValueObject':
        # Returns NEW instance
        return ValueObject(...)
```

**Aggregate Pattern:**
```python
class AggregateRoot:  # Entity
    def __init__(self):
        self._internal_collection: List = []  # Private
    
    def domain_operation(self):
        # Enforce invariants
        # Modify internal state only through this method
        pass
    
    def get_readonly_view(self):
        return self._internal_collection.copy()  # Defensive copy
```

---

## ðŸŽ¯ Remember

> "The Domain Layer is the heart of the system. Protect it from technical concerns."

**Core Principles:**
1. âœ… Business logic lives in domain objects
2. âœ… Domain has no dependencies
3. âœ… Use domain language consistently
4. âœ… Aggregates enforce invariants
5. âœ… Rich models, not anemic

**When in Doubt:**
- Ask: "Is this business logic?" â†’ Domain Layer
- Ask: "Is this orchestration?" â†’ Application Layer
- Ask: "Is this technical detail?" â†’ Infrastructure Layer

---

**Version:** 1.0  
**Last Updated:** October 2025  
**Author:** AI Engineer Path - Cursor Rules  
**Status:** ACTIVE - Apply to domain-rich applications  
**Priority:** HIGH for complex business domains
